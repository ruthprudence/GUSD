FILE: ./routes/dbCheck.js
// dbCheck.js
const express = require('express');
const router = express.Router();
const pool = require('../config/db');

router.get('/', async (req, res) => {
  try {
    const [rows] = await pool.execute('SELECT 1');
    res.json({ status: 'Connected' });
  } catch (error) {
    console.error('Database connection error:', error);
    res.status(500).json({ status: 'Error', message: error.message });
  }
});

module.exports = router;
FILE: ./routes/students.js
// routes/students.js
const express = require('express');
const router = express.Router();
const pool = require('../config/db');
const createStudentDataService = require('../services/StudentDataService');

const studentDataService = createStudentDataService(pool);

// Get students with flexible filtering
router.get('/', async (req, res) => {
  try {
    const filters = {
      grade: req.query.grade ? parseInt(req.query.grade) : null,
      school: req.query.school,
      atRiskOnly: req.query.atRiskOnly === 'true',
      graduationYear: req.query.graduationYear ? parseInt(req.query.graduationYear) : null,
      ell: req.query.ell === 'true',
      fosterCare: req.query.fosterCare === 'true'
    };
    
    const students = await studentDataService.getFilteredStudents(filters);
    res.json(students);
  } catch (err) {
    console.error('Error in students route:', err);
    res.status(500).json({ message: 'Error fetching students' });
  }
});

// Get a specific student by ID with detailed information
router.get('/:id', async (req, res) => {
  try {
    const [studentDetails] = await pool.execute(
      `SELECT s.*, 
              (SELECT COUNT(*) FROM Attendance a WHERE a.Student_ID = s.ID) as total_attendance,
              (SELECT AVG(CASE WHEN fg.Letter_Grade IN ('A', 'B') THEN 1 ELSE 0 END) FROM FinalGrades fg WHERE fg.Student_ID = s.ID) as academic_performance
       FROM Student s 
       WHERE s.ID = ?`, 
      [req.params.id]
    );

    if (studentDetails.length === 0) {
      return res.status(404).json({ message: 'Student not found' });
    }

    const [classes] = await pool.execute(
      'SELECT * FROM Classes WHERE Student_ID = ?', 
      [req.params.id]
    );

    const [attendance] = await pool.execute(
      'SELECT * FROM Attendance WHERE Student_ID = ? ORDER BY Date DESC LIMIT 10', 
      [req.params.id]
    );

    const [grades] = await pool.execute(
      'SELECT * FROM FinalGrades WHERE Student_ID = ?', 
      [req.params.id]
    );

    res.json({
      studentInfo: studentDetails[0],
      classes,
      recentAttendance: attendance,
      grades
    });
  } catch (err) {
    console.error('Error fetching student details:', err);
    res.status(500).json({ message: 'Error fetching student details' });
  }
});

module.exports = router;
FILE: ./routes/index.js
const express = require('express');
const router = express.Router();

const studentsRoutes = require('./students');
const dbCheckRoute = require('./dbCheck');

router.use('/students', studentsRoutes);
router.use('/db-status', dbCheckRoute);

module.exports = router;
FILE: ./config/config.js
// config.js
require('dotenv').config();

const config = {
  port: 3000,
};

module.exports = config;
FILE: ./config/ecosystem.config.js
module.exports = {
  apps: [
    {
      name: 'gusd-dashboard',
      script: 'server.js',
      instances: 1,
      autorestart: true,
      watch: ['server.js'],
      ignore_watch: ['node_modules'],
      max_memory_restart: '1G',
      env: {
        NODE_ENV: 'production',
      },
    },
  ],
};
FILE: ./config/middleware.js
// middleware.js
const express = require('express');
const cors = require('cors');

const corsOptions = {
  origin: '*',
  methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
  preflightContinue: false,
  optionsSuccessStatus: 200,
};

const middleware = (app) => {
  app.use(cors(corsOptions));
  app.use(express.json());
};

module.exports = middleware;
FILE: ./config/.env
DB_HOST=mysql.ruthprudence.com
DB_USER=gusd
DB_PASSWORD=gusdDATABASE!23
DB_NAME=gusd
DB_PORT=3306
FILE: ./config/db.js
// db.js
const mysql = require('mysql2/promise');
require('dotenv').config();

const pool = mysql.createPool({
  host: process.env.DB_HOST,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  port: process.env.DB_PORT,
});

// Test the connection pool
async function testConnection() {
  try {
    const [rows] = await pool.execute('SELECT 1');
    console.log('Database connection successful');
  } catch (err) {
    console.error('Error connecting to database:', err);
    process.exit(1);
  }
}

testConnection();

module.exports = pool;
FILE: ./config/server.js
// server.js
const express = require('express');
const app = express();
const config = require('./config');
const middleware = require('./middleware');
const pool = require('./db');
const routes = require('../routes');

middleware(app);

app.get('/api/data', async (req, res) => {
  try {
    const [rows] = await pool.execute('SELECT * FROM Student');
    res.json({ status: "online", data: rows }); // Return status and data
  } catch (err) {
    console.error(err);
    res.status(500).json({ status: "error", message: 'Error fetching data' });
  }
});

app.use('/api', routes);

app.get('/', (req, res) => {
  res.send('Student Data API is running');
});

app.listen(config.port, () => {
  console.log(`Server is running on port ${config.port}`);
});
FILE: ./services/cache/index.js
FILE: ./services/cache/CacheManager.js
// services/cache/CacheManager.js

class CacheManager {
  constructor() {
    this._cache = {
      students: new Map(),
      classes: new Map(),
      attendance: new Map(),
      finalGrades: new Map()
    };
  }

  async initialize(pool) {
    try {
      const [students] = await pool.execute('SELECT * FROM Student');
      const [classes] = await pool.execute('SELECT * FROM Classes');
      const [attendance] = await pool.execute('SELECT * FROM Attendance');
      const [finalGrades] = await pool.execute('SELECT * FROM FinalGrades');

      students.forEach(student => this._cache.students.set(student.ID, student));
      classes.forEach(class_ => {
        if (!this._cache.classes.has(class_.Student_ID)) {
          this._cache.classes.set(class_.Student_ID, []);
        }
        this._cache.classes.get(class_.Student_ID).push(class_);
      });
      attendance.forEach(record => {
        if (!this._cache.attendance.has(record.Student_ID)) {
          this._cache.attendance.set(record.Student_ID, []);
        }
        this._cache.attendance.get(record.Student_ID).push(record);
      });
      finalGrades.forEach(grade => {
        if (!this._cache.finalGrades.has(grade.Student_ID)) {
          this._cache.finalGrades.set(grade.Student_ID, []);
        }
        this._cache.finalGrades.get(grade.Student_ID).push(grade);
      });

      console.log('Cache initialized successfully');
    } catch (error) {
      console.error('Error initializing cache:', error);
      throw error;
    }
  }

  getStudent(studentId) {
    return this._cache.students.get(studentId);
  }

  getStudentClasses(studentId) {
    return this._cache.classes.get(studentId) || [];
  }

  getStudentAttendance(studentId) {
    return this._cache.attendance.get(studentId) || [];
  }

  getStudentGrades(studentId) {
    return this._cache.finalGrades.get(studentId) || [];
  }

  getAllStudents() {
    return Array.from(this._cache.students.values());
  }
}

module.exports = new CacheManager();
FILE: ./services/constants/graduation.js
// services/constants/graduation.js

const CREDIT_REQUIREMENTS = {
  ELA: 4.0,
  MTH: 4.0,
  SCI: 4.0,
  SS: 3.0,
  LANG: 2.0,
  ART: 1.0,
  PE: 1.0
};

const RISK_THRESHOLDS = {
  ATTENDANCE: 80,
  GRADUATION_PROGRESS: 50
};

module.exports = {
  CREDIT_REQUIREMENTS,
  RISK_THRESHOLDS
};
FILE: ./services/analytics/GraduationAnalyzer.js
// services/analytics/GraduationAnalyzer.js

const { CREDIT_REQUIREMENTS } = require('../constants/graduation');

class GraduationAnalyzer {
  calculateProgress(grades) {
    const creditsByType = {};
    
    // Initialize credit types
    Object.keys(CREDIT_REQUIREMENTS).forEach(type => {
      creditsByType[type] = 0;
    });

    // Sum credits by type
    grades.forEach(grade => {
      if (grade.Credit_Awarded && grade.Credit_Type) {
        creditsByType[grade.Credit_Type] = (creditsByType[grade.Credit_Type] || 0) + grade.Credit_Awarded;
      }
    });

    // Calculate progress for each type
    const progressByType = {};
    let totalProgress = 0;
    let totalRequired = 0;

    Object.entries(CREDIT_REQUIREMENTS).forEach(([type, required]) => {
      const earned = creditsByType[type] || 0;
      progressByType[type] = Math.min(100, (earned / required) * 100);
      totalProgress += Math.min(required, earned);
      totalRequired += required;
    });

    return {
      overallProgress: (totalProgress / totalRequired) * 100,
      creditsByType,
      progressByType
    };
  }
}

module.exports = new GraduationAnalyzer();
FILE: ./services/analytics/AttendanceAnalyzer.js
// services/analytics/AttendanceAnalyzer.js

class AttendanceAnalyzer {
  calculateAttendanceRate(records) {
    if (records.length === 0) return 100;

    const presentCodes = ['P', 'T']; // Present and Tardy
    const present = records.filter(record => presentCodes.includes(record.Code)).length;
    return (present / records.length) * 100;
  }
}

module.exports = new AttendanceAnalyzer();
FILE: ./services/analytics/RiskAnalyzer.js
// services/analytics/RiskAnalyzer.js

const { RISK_THRESHOLDS } = require('../constants/graduation');

class RiskAnalyzer {
  assessRisk(attendanceRate, grades, graduationProgress) {
    const hasFailingGrades = grades.some(grade => grade.Letter_Grade === 'F');

    return {
      isAtRisk: attendanceRate < RISK_THRESHOLDS.ATTENDANCE || 
                hasFailingGrades || 
                graduationProgress < RISK_THRESHOLDS.GRADUATION_PROGRESS,
      factors: {
        lowAttendance: attendanceRate < RISK_THRESHOLDS.ATTENDANCE,
        failingGrades: hasFailingGrades,
        insufficientProgress: graduationProgress < RISK_THRESHOLDS.GRADUATION_PROGRESS
      }
    };
  }
}

module.exports = new RiskAnalyzer();
FILE: ./services/StudentDataService.js
// services/StudentDataService.js
class StudentDataService {
  constructor(pool) {
    this.pool = pool;
  }

  async getFilteredStudents(filters = {}) {
    try {
      // Build the base query
      let query = `
        SELECT 
          s.*,
          GROUP_CONCAT(DISTINCT f.Letter_Grade) as grades,
          COUNT(DISTINCT a.ID) as attendance_count,
          SUM(DISTINCT f.Credit_Awarded) as total_credits
        FROM Student s
        LEFT JOIN FinalGrades f ON s.ID = f.Student_ID
        LEFT JOIN Attendance a ON s.ID = a.Student_ID
      `;

      const whereConditions = [];
      const params = [];

      // Add filter conditions
      if (filters.grade) {
        whereConditions.push('s.Grade = ?');
        params.push(filters.grade);
      }
      if (filters.school) {
        whereConditions.push('s.School = ?');
        params.push(filters.school);
      }
      if (filters.graduationYear) {
        whereConditions.push('s.Expected_Graduation = ?');
        params.push(filters.graduationYear);
      }
      if (filters.ell) {
        whereConditions.push('s.Flag_EnglishLanguageLearner = 1');
      }
      if (filters.fosterCare) {
        whereConditions.push('s.Flag_FosterCare = 1');
      }

      if (whereConditions.length > 0) {
        query += ' WHERE ' + whereConditions.join(' AND ');
      }

      query += ' GROUP BY s.ID';
      console.log('Executing query:', query, 'with params:', params);

      const [students] = await this.pool.execute(query, params);
      console.log('Found students:', students.length);

      return students.map(student => ({
        ...student,
        graduationProgress: this.calculateGraduationProgress(student),
        isAtRisk: this.calculateRiskStatus(student)
      }));
    } catch (error) {
      console.error('Error in getFilteredStudents:', error);
      throw error;
    }
  }

  calculateGraduationProgress(student) {
    const totalCredits = parseFloat(student.total_credits) || 0;
    const requiredCredits = 220; // Your required credits
    return Math.min((totalCredits / requiredCredits) * 100, 100);
  }

  calculateRiskStatus(student) {
    const grades = student.grades ? student.grades.split(',') : [];
    const hasFailingGrade = grades.some(grade => grade === 'F');
    const lowCredits = this.calculateGraduationProgress(student) < 70;
    return hasFailingGrade || lowCredits;
  }
}

module.exports = pool => new StudentDataService(pool);
FILE: ./output.txt
